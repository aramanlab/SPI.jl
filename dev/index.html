<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Home · SPI.jl</title><script data-outdated-warner src="assets/warner.js"></script><link rel="canonical" href="https://aramanlab.github.io/SPI.jl/"/><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.039/juliamono-regular.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.11/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="assets/documenter.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href>SPI.jl</a></span></div><form class="docs-search" action="search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li class="is-active"><a class="tocitem" href>Home</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Home</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Home</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/aramanlab/SPI.jl/blob/master/docs/src/index.md#" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="SPI"><a class="docs-heading-anchor" href="#SPI">SPI</a><a id="SPI-1"></a><a class="docs-heading-anchor-permalink" href="#SPI" title="Permalink"></a></h1><p>Documentation for <a href="https://github.com/aramanlab/SPI.jl">SPI</a>.</p><ul><li><a href="#SPI.adjustedrandindex-Tuple{AbstractVector{&lt;:Number}, AbstractVector{&lt;:Number}}"><code>SPI.adjustedrandindex</code></a></li><li><a href="#SPI.calc_spi_mtx-Tuple{AbstractMatrix{&lt;:Number}}"><code>SPI.calc_spi_mtx</code></a></li><li><a href="#SPI.calc_spi_trace-Tuple{SVD}"><code>SPI.calc_spi_trace</code></a></li><li><a href="#SPI.calc_spi_tree-Tuple{Any}"><code>SPI.calc_spi_tree</code></a></li><li><a href="#SPI.empiricalMI-Union{Tuple{T}, Tuple{AbstractVector{T}, AbstractVector{T}}} where T&lt;:AbstractFloat"><code>SPI.empiricalMI</code></a></li><li><a href="#SPI.getintervals-Tuple{AbstractVector{&lt;:Number}}"><code>SPI.getintervals</code></a></li><li><a href="#SPI.minspaceneeded-Tuple{Any, Any}"><code>SPI.minspaceneeded</code></a></li><li><a href="#SPI.nwstr-Tuple{Clustering.Hclust}"><code>SPI.nwstr</code></a></li><li><a href="#SPI.pairwise-Union{Tuple{M}, Tuple{Function, M}} where M&lt;:(AbstractMatrix)"><code>SPI.pairwise</code></a></li><li><a href="#SPI.projectinLSV-Union{Tuple{T}, Tuple{AbstractArray{T}, SVD{T, Tr, M} where {Tr, M&lt;:(AbstractArray{T})}}} where T&lt;:Number"><code>SPI.projectinLSV</code></a></li><li><a href="#SPI.projectinRSV-Union{Tuple{T}, Tuple{AbstractArray{T}, SVD{T, Tr, M} where {Tr, M&lt;:(AbstractArray{T})}}} where T&lt;:Number"><code>SPI.projectinRSV</code></a></li><li><a href="#SPI.projectout-Tuple{SVD}"><code>SPI.projectout</code></a></li><li><a href="#SPI.readphylip-Tuple{AbstractString}"><code>SPI.readphylip</code></a></li><li><a href="#SPI.scaledcumsum-Tuple{Any}"><code>SPI.scaledcumsum</code></a></li><li><a href="#SPI.spimtx_spaceneeded-Tuple{Any}"><code>SPI.spimtx_spaceneeded</code></a></li><li><a href="#SPI.spiresult-Tuple{AbstractMatrix{&lt;:Number}}"><code>SPI.spiresult</code></a></li><li><a href="#SPI.vmeasure_homogeneity_completeness-Tuple{Any, Any}"><code>SPI.vmeasure_homogeneity_completeness</code></a></li><li><a href="#SPI.zscore-Tuple{Any}"><code>SPI.zscore</code></a></li></ul><article class="docstring"><header><a class="docstring-binding" id="SPI.adjustedrandindex-Tuple{AbstractVector{&lt;:Number}, AbstractVector{&lt;:Number}}" href="#SPI.adjustedrandindex-Tuple{AbstractVector{&lt;:Number}, AbstractVector{&lt;:Number}}"><code>SPI.adjustedrandindex</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">adjustedrandindex(a::AbstractVector{&lt;:Number}, b::AbstractVector{&lt;:Number}; nbins=50)</code></pre><p>Args:</p><ul><li>a, vector of numbers</li><li>b, vector of numbers</li><li>nbins, for continuous approximates discrete, for discrete choose nbins&gt;max<em>number</em>of_classes</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aramanlab/SPI.jl/blob/3b53447396b22e63b535ad79282c368fca3cbae4/src/empiricalMI.jl#L167-L175">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SPI.calc_spi_mtx-Tuple{AbstractMatrix{&lt;:Number}}" href="#SPI.calc_spi_mtx-Tuple{AbstractMatrix{&lt;:Number}}"><code>SPI.calc_spi_mtx</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">calc_spi_mtx(A::AbstractMatrix; [Nsmps=size(A,1), Nfeats=size(A,2), alpha=1.5, q=.75])
calc_spi_mtx(usv::SVD; [Nsmps=size(A,1), Nfeats=size(A,2), alpha=1.5, q=.75])
calc_spi_mtx(usv::SVD[, SPI.LSVs(); Nsmps=size(A,1), Nfeats=size(A,2), alpha=1.5, q=.75])
calc_spi_mtx(usv::SVD[, SPI.RSVs(); Nsmps=size(A,1), Nfeats=size(A,2), alpha=1.5, q=.75])</code></pre><p>computes the cumulative spectral residual distance for spectral phylogenetic inference</p><p><code>(∑_{p ∈ P} ||UₚΣₚ||₂)²</code></p><p>where <span>$P$</span> are the spectral partitions found with <code>getintervals</code>. </p><p>Args:</p><ul><li>A,usv = AbstractMatrix or SVD factorization (AbstractMatrix is just passed to <code>svd()</code> before calculation)</li><li>SPI.Left() computes SPI matrix for LSVs; SPI.Right() computes SPI matrix for RSVs</li><li>alpha, q are passed to <code>getintervals()</code> see its documentation</li></ul><p>Returns:</p><ul><li>distance matrix</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aramanlab/SPI.jl/blob/3b53447396b22e63b535ad79282c368fca3cbae4/src/core.jl#L51-L71">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SPI.calc_spi_trace-Tuple{SVD}" href="#SPI.calc_spi_trace-Tuple{SVD}"><code>SPI.calc_spi_trace</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">calc_spi_trace(usv::SVD; alpha=1.5, q=.75)
calc_spi_trace(usv::SVD[, taxaidxs]; alpha=1.5, q=.75)</code></pre><p>calculates spectral residual within each partition of spectrum and each pair of taxa</p><p>if <code>taxaidxs</code> are provided the <code>U</code> matrix is subset and/or reordered based on those indices.</p><p>returns matrix where rows are spectral partitions and columns are taxa:taxa pairs ordered as the upper triangle in rowwise order. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aramanlab/SPI.jl/blob/3b53447396b22e63b535ad79282c368fca3cbae4/src/core.jl#L92-L103">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SPI.calc_spi_tree-Tuple{Any}" href="#SPI.calc_spi_tree-Tuple{Any}"><code>SPI.calc_spi_tree</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">calc_spi_tree(A[, ids; labelinternalnodes=true])</code></pre><p>helper function that immediately returns the newick tree string inferred by SPI</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aramanlab/SPI.jl/blob/3b53447396b22e63b535ad79282c368fca3cbae4/src/core.jl#L129-L132">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SPI.empiricalMI-Union{Tuple{T}, Tuple{AbstractVector{T}, AbstractVector{T}}} where T&lt;:AbstractFloat" href="#SPI.empiricalMI-Union{Tuple{T}, Tuple{AbstractVector{T}, AbstractVector{T}}} where T&lt;:AbstractFloat"><code>SPI.empiricalMI</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">empiricalMI(a::AbstractVector{&lt;:Float}, b::AbstractVector{&lt;:Float}[, nbins=50, normalize=false])</code></pre><p>computes empirical MI from identity of <span>$H(a) + H(b) - H(a,b)$</span>. where <span>$H := -sum(p(x)*log(p(x))) + log(Δ)$</span> the <span>$+ log(Δ)$</span> corresponds to the log binwidth and unbiases the entropy estimate from binwidth choice. estimates are roughly stable from <span>$32$</span> (<span>$32^2 ≈ 1000$</span> total bins) to size of sample. going from a small undersestimate to a small overestimate across that range. We recommend choosing the <code>sqrt(mean(1000, samplesize))</code> for <code>nbins</code> argument, or taking a few estimates across that range and averaging.</p><p>Args:</p><ul><li>a, vecter of length N</li><li>b, AbstractVector of length N</li><li>nbins, number of bins per side, use 1000 &lt; nbins^2 &lt; length(a) for best results</li><li>normalize, bool, whether to normalize with mi / mean(ha, hb)</li></ul><p>Returns:</p><ul><li>MI</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aramanlab/SPI.jl/blob/3b53447396b22e63b535ad79282c368fca3cbae4/src/empiricalMI.jl#L3-L20">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SPI.getintervals-Tuple{AbstractVector{&lt;:Number}}" href="#SPI.getintervals-Tuple{AbstractVector{&lt;:Number}}"><code>SPI.getintervals</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">getintervals(S::AbstractVector{&lt;:Number}; alpha=1.5, q=.75)</code></pre><p>finds spectral partitions. Computes log difference between each subsequent singular value and by default selects the differences that are larger than <code>1.5 * Q3(differences)</code></p><p>i.e. finds breaks in the spectrum that explain smaller scales of variance</p><p>Args:</p><ul><li>S = singular values of a SVD factorization</li><li>alpha = scalar multiple of <code>q</code></li><li>q = which quantile of log differences to use; by default Q3 </li></ul><p>Returns:</p><ul><li>AbstractVector{UnitRange} indices into S corresponding to the spectral partitions</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aramanlab/SPI.jl/blob/3b53447396b22e63b535ad79282c368fca3cbae4/src/core.jl#L24-L40">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SPI.minspaceneeded-Tuple{Any, Any}" href="#SPI.minspaceneeded-Tuple{Any, Any}"><code>SPI.minspaceneeded</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">minspaceneeded(n, p; bits=64) = Base.format_bytes(binomial(n,2) * p * bits)</code></pre><p>how much memory is needed to store spectral residual trace</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aramanlab/SPI.jl/blob/3b53447396b22e63b535ad79282c368fca3cbae4/src/helpers.jl#L21-L25">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SPI.nwstr-Tuple{Clustering.Hclust}" href="#SPI.nwstr-Tuple{Clustering.Hclust}"><code>SPI.nwstr</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">nwstr(hc::Hclust[, tiplabels::AbstractVector[&lt;:String]])</code></pre><p>convert Hclust to newick tree string Args:</p><ul><li>hc, <code>Hclust</code> object from Clustering package</li><li>tiplabels, <code>AbstractVector{&lt;:String}</code> names in same order as distance matrix</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aramanlab/SPI.jl/blob/3b53447396b22e63b535ad79282c368fca3cbae4/src/helpers.jl#L51-L59">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SPI.pairwise-Union{Tuple{M}, Tuple{Function, M}} where M&lt;:(AbstractMatrix)" href="#SPI.pairwise-Union{Tuple{M}, Tuple{Function, M}} where M&lt;:(AbstractMatrix)"><code>SPI.pairwise</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">pairwise(func::Function, m::M) where M&lt;:AbstractMatrix</code></pre><p>returns upper offdiagonals of <code>res[k] = func(i, j)</code> where <code>(k, (i,j))</code>  are calculated from <code>enumerate(combinations(1:size(m,2), 2))</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aramanlab/SPI.jl/blob/3b53447396b22e63b535ad79282c368fca3cbae4/src/helpers.jl#L36-L41">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SPI.projectinLSV-Union{Tuple{T}, Tuple{AbstractArray{T}, SVD{T, Tr, M} where {Tr, M&lt;:(AbstractArray{T})}}} where T&lt;:Number" href="#SPI.projectinLSV-Union{Tuple{T}, Tuple{AbstractArray{T}, SVD{T, Tr, M} where {Tr, M&lt;:(AbstractArray{T})}}} where T&lt;:Number"><code>SPI.projectinLSV</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">projectinLSV(data::AbstractArray{T}, usv::SVD{T}, [window])</code></pre><p>returns estimated left singular vectors (aka: LSV or Û) for new data based on already calculated SVD factorization</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aramanlab/SPI.jl/blob/3b53447396b22e63b535ad79282c368fca3cbae4/src/core.jl#L144-L148">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SPI.projectinRSV-Union{Tuple{T}, Tuple{AbstractArray{T}, SVD{T, Tr, M} where {Tr, M&lt;:(AbstractArray{T})}}} where T&lt;:Number" href="#SPI.projectinRSV-Union{Tuple{T}, Tuple{AbstractArray{T}, SVD{T, Tr, M} where {Tr, M&lt;:(AbstractArray{T})}}} where T&lt;:Number"><code>SPI.projectinRSV</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">projectinRSV(data::AbstractArray{T}, usv::SVD{T}, [window])</code></pre><p>returns estimated transposed right singular vectors (RSV or V̂ᵗ) for new data based on already calculated SVD factorization</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aramanlab/SPI.jl/blob/3b53447396b22e63b535ad79282c368fca3cbae4/src/core.jl#L152-L156">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SPI.projectout-Tuple{SVD}" href="#SPI.projectout-Tuple{SVD}"><code>SPI.projectout</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">projectout(usv::SVD, [window])</code></pre><p>recreates original matrix i.e. calculates <span>$UΣV&#39;$</span> or if window is included  creates a spectrally filtered version of the original matrix off of the provided components in <code>window</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aramanlab/SPI.jl/blob/3b53447396b22e63b535ad79282c368fca3cbae4/src/core.jl#L160-L165">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SPI.readphylip-Tuple{AbstractString}" href="#SPI.readphylip-Tuple{AbstractString}"><code>SPI.readphylip</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">readphylip(fn::String)</code></pre><p>Read phylip alignment file, return dataframe of IDs and Sequences</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aramanlab/SPI.jl/blob/3b53447396b22e63b535ad79282c368fca3cbae4/src/parsephylip.jl#L2-L6">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SPI.scaledcumsum-Tuple{Any}" href="#SPI.scaledcumsum-Tuple{Any}"><code>SPI.scaledcumsum</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">scaledcumsum(c; dims=1)</code></pre><p>cumsum divided by maximum cumulative value</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aramanlab/SPI.jl/blob/3b53447396b22e63b535ad79282c368fca3cbae4/src/helpers.jl#L10-L14">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SPI.spimtx_spaceneeded-Tuple{Any}" href="#SPI.spimtx_spaceneeded-Tuple{Any}"><code>SPI.spimtx_spaceneeded</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">spimtx_spaceneeded(n, p; bits=64) = Base.format_bytes(binomial(n,2) * p * bits)</code></pre><p>how much memory is needed to store SPI distance matrix</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aramanlab/SPI.jl/blob/3b53447396b22e63b535ad79282c368fca3cbae4/src/helpers.jl#L28-L32">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SPI.spiresult-Tuple{AbstractMatrix{&lt;:Number}}" href="#SPI.spiresult-Tuple{AbstractMatrix{&lt;:Number}}"><code>SPI.spiresult</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">spiresult(A::AbstractMatrix{&lt;:Number})</code></pre><p>convenience function for optaining SVD, SPImtx, and SPItree</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aramanlab/SPI.jl/blob/3b53447396b22e63b535ad79282c368fca3cbae4/src/core.jl#L11-L15">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SPI.vmeasure_homogeneity_completeness-Tuple{Any, Any}" href="#SPI.vmeasure_homogeneity_completeness-Tuple{Any, Any}"><code>SPI.vmeasure_homogeneity_completeness</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">vmeasure_homogeneity_completeness(labels_true, labels_pred; β=1.)</code></pre><p>calculates and returns v-measure, homogeneity, completeness; similar to f-score, precision, and recall respectively</p><p>Args:</p><ul><li>β, weighting term for v-measure, if β is greater than 1 completeness</li></ul><p>is weighted more strongly in the calculation, if β is less than 1,  homogeneity is weighted more strongly</p><p>Citation:</p><ul><li>A. Rosenberg, J. Hirschberg, in Proceedings of the 2007 Joint Conference</li></ul><p>on Empirical Methods in Natural Language Processing and Computational Natural  Language Learning (EMNLP-CoNLL) (Association for Computational Linguistics,   Prague, Czech Republic, 2007; https://aclanthology.org/D07-1043), pp. 410–420.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aramanlab/SPI.jl/blob/3b53447396b22e63b535ad79282c368fca3cbae4/src/empiricalMI.jl#L125-L141">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SPI.zscore-Tuple{Any}" href="#SPI.zscore-Tuple{Any}"><code>SPI.zscore</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">zscore by columns by default. set dims=2 for rows</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aramanlab/SPI.jl/blob/3b53447396b22e63b535ad79282c368fca3cbae4/src/helpers.jl#L2-L4">source</a></section></article></article><nav class="docs-footer"><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.15 on <span class="colophon-date" title="Thursday 19 May 2022 21:51">Thursday 19 May 2022</span>. Using Julia version 1.7.2.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
